---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.2'
      jupytext_version: 1.5.1
  kernelspec:
    display_name: collatz
    language: python
    name: collatz
---

<!-- #region pycharm={"name": "#%% md\n"} -->
## Collatz binary graph
<!-- #endregion -->

```python pycharm={"name": "#%%\n"}
"""
This experimental notebook analyses the binary representation of Collatz sequences from
a graph-theoretic perspective. It builds on a sample of sequences, stored in the csv file:
data/alpha_sequences.csv. The file can be generated by executing the script
run_alpha_export.py.
"""

from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
import networkx as nx
import nbutils
from collatz import commons


# Helper methods
def _to_binary(int_value):
    """
    This method returns the binary representation of
    a specific int value as string.
    :param int_value: The int value, if a str is handed
    over it is converted to an int.
    :return: The binary representation as string.
    """
    if type(int_value) == str:
        int_value = int(int_value)
    return commons.to_binary(int_value)


# Configuration
K_FACTOR = 3
EXPORT_DATA = True
DATA_PATH = Path.cwd().parent.as_posix() + "/data/"
INPUT_PATH = DATA_PATH + "alpha_export.csv"
EXPORT_PIC_PATH = DATA_PATH + "binary_graph.png"
EXPORT_CSV_PATH = DATA_PATH + "binary_graph.csv"
SHOW_LABELS = True

nbutils.set_default_pd_options()

# Load data from csv
analysis_frame = pd.read_csv(
    INPUT_PATH, dtype={
        "v_i": object, "kv_i+1": object, "v_i+" : object,
        "v_1_bin" : str, "v_i_bin" : str})

# Filter data set
analysis_frame = analysis_frame[analysis_frame["k"] == K_FACTOR]

# Print meta data
sequence_count = int(analysis_frame["sequence_id"].nunique())

print("Collatz sequences loaded from file:", sequence_count, "\n")
print("Count of Collatz values:", len(analysis_frame), "\n")

# Derive additional features
analysis_frame["v_i_log2"].astype('int64') + 1

# Binary
max_bin_len = int(analysis_frame["bin_len"].max())
analysis_frame["bin_str"] = analysis_frame["v_i"].apply(_to_binary).str.zfill(max_bin_len)

analysis_frame["b2"] = analysis_frame["bin_str"].str[max_bin_len-2]
analysis_frame["b3"] = analysis_frame["bin_str"].str[max_bin_len-3]
analysis_frame["b4"] = analysis_frame["bin_str"].str[max_bin_len-4]
analysis_frame["b32"] = analysis_frame["b3"].astype('str') + analysis_frame["b2"]
analysis_frame["b432"] = analysis_frame["b4"].astype('str') + analysis_frame["b32"]
```

```python pycharm={"name": "#%%\n"}
analysis_frame["predecessor"] = analysis_frame["b32"]
analysis_frame["successor"] = analysis_frame["predecessor"]
analysis_frame.loc[analysis_frame["terminal"] == True, ["predecessor"]] = "x"

predecessor = analysis_frame["predecessor"][:-1]
successor = analysis_frame["successor"][1:]
v_i = analysis_frame["v_i"][:-1]
v_ip = analysis_frame["v_i"][1:]
lambda_i = analysis_frame["l_i"][:-1]
alpha_i = analysis_frame["a_i"][:-1]
omega_i = analysis_frame["o_i"][:-1]

graph_frame = pd.DataFrame({
    "predecessor": list(predecessor),
    "successor": list(successor),
    "lambda_i": list(lambda_i),
    "alpha_i": list(alpha_i),
    "omega_i": list(omega_i)
})

graph_frame = graph_frame[graph_frame["predecessor"] != "x"]

edge_frame = graph_frame.groupby(["predecessor", "successor"])["lambda_i"].count().reset_index()
edge_frame.columns = ["predecessor", "successor", "count"]
edge_frame["percent"] = edge_frame["count"] / edge_frame["count"].sum()
edge_frame["weight"] = edge_frame["percent"] * 25

print("Edges:\n")
print(edge_frame, "\n")

print("Nodes:\n")
print(graph_frame.groupby(["predecessor"])[["lambda_i", "alpha_i", "omega_i"]].mean())
```

```python pycharm={"name": "#%%\n"}
# Plot Graph
plt.figure(figsize=(20,10))
plt.title("k=" + str(K_FACTOR))

network = nx.convert_matrix.from_pandas_edgelist(
    edge_frame, source="predecessor", target="successor",
    create_using=nx.DiGraph(), edge_attr=True)

edges = network.edges()
widths = [network[u][v]['weight'] for u,v in edges]

pos = nx.circular_layout(network)
nx.draw(network, pos, node_size=1000, with_labels=SHOW_LABELS,
        arrows=True, arrowsize=30, width=widths)

# Export data
if EXPORT_DATA:
    plt.savefig(EXPORT_PIC_PATH)
    export_frame = edge_frame.rename(
        columns={"predecessor": "source", "successor": "target"})
    export_frame.to_csv(EXPORT_CSV_PATH, index=False)

# Show graph
plt.show()

if EXPORT_DATA:
    print("Graph saved:" + EXPORT_PIC_PATH)
```
