---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.13.8
  kernelspec:
    display_name: collatz
    language: python
    name: collatz
---

<!-- #region pycharm={"name": "#%% md\n"} -->
## Collatz binary trailing graph
<!-- #endregion -->

```python pycharm={"name": "#%%\n"}
"""
This experimental notebook analyses the binary representation of Collatz sequences from
a graph-theoretic perspective and focuses on the trailing digits. It builds on a sample
of sequences, stored in the csv file: *data/alpha_export.csv*.

The file can be generated by executing the following command:
>>> python run_alpha_export.py
"""

from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
import networkx as nx
import nbutils

# Configuration
K_FACTOR = 3
EXPORT_DATA = True
DATA_PATH = Path.cwd().parent.as_posix() + "/data/"
INPUT_PATH = DATA_PATH + "alpha_export.csv"
EXPORT_PIC_PATH = DATA_PATH + "binary_trailing_graph.png"
EXPORT_CSV_PATH = DATA_PATH + "binary_trailing_graph.csv"
SHOW_LABELS = True

nbutils.set_default_pd_options()

# Load data from csv
analysis_frame = pd.read_csv(
    INPUT_PATH, dtype={
        "v_i": object, "kv_i+1": object, "v_i+" : object,
        "v_1_bin" : str, "v_i_bin" : str})

# Filter data set
analysis_frame = analysis_frame[analysis_frame["k"] == K_FACTOR]

# Print meta data
sequence_count = int(analysis_frame["sequence_id"].nunique())

print("Collatz sequences loaded from file:", sequence_count)
print("Count of Collatz values:", len(analysis_frame), "\n")
print("K:", K_FACTOR, "\n")

# Derive additional features

# Binary
max_bin_len = int(analysis_frame["bin_len"].max())
analysis_frame["bin_str"] = analysis_frame["v_i_bin"].str.zfill(max_bin_len)
analysis_frame["t1"] = analysis_frame["bin_str"].str[max_bin_len-1]
analysis_frame["t2"] = analysis_frame["bin_str"].str[max_bin_len-2]
analysis_frame["t3"] = analysis_frame["bin_str"].str[max_bin_len-3]
analysis_frame["t4"] = analysis_frame["bin_str"].str[max_bin_len-4]
analysis_frame["t321"] = \
    analysis_frame["t3"].astype('str') + analysis_frame["t2"] + analysis_frame["t1"]

analysis_frame["t4321"] = analysis_frame["t4"].astype('str') + analysis_frame["t321"]
```

```python pycharm={"name": "#%%\n"}
analysis_frame["predecessor"] = analysis_frame["t321"]
analysis_frame["successor"] = analysis_frame["predecessor"]
# If terminal is true, set predecessor = x
analysis_frame.loc[analysis_frame["terminal"], ["predecessor"]] = "x"

predecessor = analysis_frame["predecessor"][:-1]
successor = analysis_frame["successor"][1:]
v_i = analysis_frame["v_i"][:-1]
v_ip = analysis_frame["v_i"][1:]
lambda_i = analysis_frame["l_i"][:-1]
alpha_i = analysis_frame["a_i"][:-1]
omega_i = analysis_frame["o_i"][:-1]

graph_frame = pd.DataFrame({
    "predecessor": list(predecessor),
    "successor": list(successor),
    "lambda_i": list(lambda_i),
    "alpha_i": list(alpha_i),
    "omega_i": list(omega_i)
})

graph_frame = graph_frame[graph_frame["predecessor"] != "x"]

edge_frame = graph_frame.groupby(
    ["predecessor", "successor"]).agg(
    a_max=("alpha_i", "max"), a_min=("alpha_i", "min"),
    l_max=("lambda_i", "max"), l_min=("lambda_i", "min"),
    o_max=("omega_i", "max"), o_median=("omega_i", "median"),
    o_min=("omega_i", "min"), count=("lambda_i", "count")).reset_index()

edge_frame["percent"] = edge_frame["count"] / edge_frame["count"].sum()
edge_frame["weight"] = edge_frame["percent"] * 25 + 1

print("Edges:\n")
print(edge_frame, "\n")

print("Nodes:\n")
print(graph_frame.groupby(["predecessor"]).agg(
    a_max=("alpha_i", "max"), a_min=("alpha_i", "min"),
    l_max=("lambda_i", "max"), l_min=("lambda_i", "min"),
    o_max=("omega_i", "max"), o_median=("omega_i", "median"),
    o_min=("omega_i", "min"), count=("lambda_i", "count")).reset_index())
```

```python pycharm={"name": "#%%\n"}
# Plot Graph
plt.figure(figsize=(20, 10))
plt.title("k=" + str(K_FACTOR))

network = nx.convert_matrix.from_pandas_edgelist(
    edge_frame, source="predecessor", target="successor",
    create_using=nx.DiGraph(), edge_attr=True)

edges = network.edges()
widths = [network[u][v]['weight'] for u, v in edges]

pos = nx.circular_layout(network)
nx.draw(network, pos, node_size=1000, with_labels=SHOW_LABELS,
        arrows=True, arrowsize=30, width=widths)

edge_labels = nx.get_edge_attributes(network,'o_max')

nx.draw_networkx_edge_labels(
    network, pos=pos, edge_labels=edge_labels, label_pos=0.15)

# Export data
if EXPORT_DATA:
    plt.savefig(EXPORT_PIC_PATH)
    export_frame = edge_frame.rename(
        columns={"predecessor": "source", "successor": "target"})
    export_frame.to_csv(EXPORT_CSV_PATH, index=False)

# Show graph
plt.show()

if EXPORT_DATA:
    print("Graph saved:" + EXPORT_PIC_PATH)
```
